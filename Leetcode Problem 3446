1) C++:
class Solution {
public:
    vector<vector<int>> sortMatrix(vector<vector<int>>& grid) {
        int n = grid.size();
        for (int j = 0; j < n; j++) {
            vector<int> diag;
            int r = 0, c = j;
            while (r < n && c < n) {
                diag.push_back(grid[r][c]);
                r++;
                c++;
            }
            if (0 < j) sort(diag.begin(), diag.end());
            else sort(diag.rbegin(), diag.rend());
            r = 0, c = j;
            int idx = 0;
            while (r < n && c < n) {
                grid[r][c] = diag[idx++];
                r++;
                c++;
            }
        }
        for (int i = 1; i < n; i++) {
            vector<int> diag;
            int r = i, c = 0;
            while (r < n && c < n) {
                diag.push_back(grid[r][c]);
                r++;
                c++;
            }
            sort(diag.rbegin(), diag.rend());
            r = i, c = 0;
            int idx = 0;
            while (r < n && c < n) {
                grid[r][c] = diag[idx++];
                r++;
                c++;
            }
        }
        return grid;
    }
};



2) Java :
class Solution {
    public int[][] sortMatrix(int[][] grid) {
        int n = grid.length;
        for (int j = 0; j < n; j++) {
            List<Integer> diag = new ArrayList<>();
            int r = 0, c = j;
            while (r < n && c < n) {
                diag.add(grid[r][c]);
                r++;
                c++;
            }
            if (j > 0) {
                Collections.sort(diag);
            } else {
                diag.sort(Collections.reverseOrder());
            }
            r = 0;
            c = j;
            int idx = 0;
            while (r < n && c < n) {
                grid[r][c] = diag.get(idx++);
                r++;
                c++;
            }
        }
        for (int i = 1; i < n; i++) {
            List<Integer> diag = new ArrayList<>();
            int r = i, c = 0;
            while (r < n && c < n) {
                diag.add(grid[r][c]);
                r++;
                c++;
            }
            diag.sort(Collections.reverseOrder());
            r = i;
            c = 0;
            int idx = 0;
            while (r < n && c < n) {
                grid[r][c] = diag.get(idx++);
                r++;
                c++;
            }
        }
        return grid;
    }
}


3) Python : 
class Solution:
    def sortMatrix(self, grid):
        n = len(grid)
        for j in range(n):
            diag = []
            r, c = 0, j
            while r < n and c < n:
                diag.append(grid[r][c])
                r += 1
                c += 1
            if j > 0:
                diag.sort()
            else:
                diag.sort(reverse=True)
            r, c, idx = 0, j, 0
            while r < n and c < n:
                grid[r][c] = diag[idx]
                idx += 1
                r += 1
                c += 1
        for i in range(1, n):
            diag = []
            r, c = i, 0
            while r < n and c < n:
                diag.append(grid[r][c])
                r += 1
                c += 1
            diag.sort(reverse=True)
            r, c, idx = i, 0, 0
            while r < n and c < n:
                grid[r][c] = diag[idx]
                idx += 1
                r += 1
                c += 1
        return grid

